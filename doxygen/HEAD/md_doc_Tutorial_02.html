<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>sot-doc: Tutorial_02</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pinocchio.ico" rel="icon" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="MathJax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sot.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sot-doc
   &#160;<span id="projectnumber">0.0.1-dirty</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_Tutorial_02.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial_02 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tutorial_snd"></a>
Whole body motion</h1>
<h2><a class="anchor" id="tutorial_snd_introduction"></a>
Introduction</h2>
<p>This tutorial gives a brief high level view of a complete whole body motion with a complex behavior using several components of the SoT.</p>
<p>It is assumed that:</p>
<ol type="1">
<li>the stack of tasks has been installed using the installation instruction provided [there](download);</li>
<li>you understood the [dynamic graph mechanism](a_dynamic_graph).</li>
</ol>
<p>This tutorial details some examples to test the stack of tasks framework on the humanoid robot TALOS.</p>
<h3><a class="anchor" id="tutorial_snd_introduction_kinetic"></a>
For Kinetic</h3>
<p>To visualize the robot, you need to have ROS and the following packages for ROS Kinetic: </p><div class="fragment"><div class="line">sudo apt-get install ros-kinetic-twist-mux ros-kinetic-joy-teleop ros-kinetic-moveit-ros-move-group ros-kinetic-humanoid-nav-msgs ros-kinetic-play-motion ros-kinetic-ompl ros-kinetic-moveit-planners-ompl ros-kinetic-moveit-simple-controller-manager</div></div><!-- fragment --><h3><a class="anchor" id="tutorial_snd_introduction_kinetic"></a>
For Kinetic</h3>
<p>You also need the following robotpkg binaries: </p><div class="fragment"><div class="line">sudo apt-get install robotpkg-talos-dev</div></div><!-- fragment --><h3>Setting up your environment</h3>
<h4>Quick start</h4>
<p>Copy the bash file <a href="../shscripts/setup-opt-testrobotpkgarg.sh">setup-opt-testrobotpkgargs.sh</a> in the following directory: </p><div class="fragment"><div class="line">$HOME/bin</div></div><!-- fragment --><p> The following assume a clean environment where only </p><div class="fragment"><div class="line">/opt/ros/kinetic/setup.bash </div></div><!-- fragment --><p> has been called. You can then either source the file when you want to perform simulation, or temporary modifies your .bashrc file by adding: </p><div class="fragment"><div class="line">source /home/user/bin/setup-opt-testrobotpkgarg.sh /opt/openrobots 1</div></div><!-- fragment --> <h4>Detailed explanations</h4>
<p>The script <b>setup-opt-testrobotpkgarg.sh</b> simply set a number of important environment variables given one or two arguments. The first argument, used in both cases, is the directory where the robotpkg software is installed. If present the second argument imposes that these variables are the first ones to be considered in the current terminal.</p>
<p>It is necessary for TALOS because some classical ROS packages must have a lower priority.</p>
<div class="fragment"><div class="line">if [ $# -eq 2 ];</div><div class="line">then</div><div class="line">  export ROBOTPKG_BASE=$1</div><div class="line">  export PATH=$ROBOTPKG_BASE/sbin:$ROBOTPKG_BASE/bin:$PATH</div><div class="line">  export LD_LIBRARY_PATH=$ROBOTPKG_BASE/lib:$ROBOTPKG_BASE/lib/plugin:$ROBOTPKG_BASE/lib64:$LD_LIBRARY_PATH</div><div class="line">  export PYTHONPATH=$ROBOTPKG_BASE/lib/python2.7/site-packages:$ROBOTPKG_BASE/lib/python2.7/dist-packages:$PYTHONPATH</div><div class="line">  export PKG_CONFIG_PATH=$ROBOTPKG_BASE/lib/pkgconfig/:$PKG_CONFIG_PATH</div><div class="line">  export ROS_PACKAGE_PATH=$ROBOTPKG_BASE/share:$ROBOTPKG_BASE/stacks:$ROS_PACKAGE_PATH</div><div class="line">  export CMAKE_PREFIX_PATH=$ROBOTPKG_BASE:$CMAKE_PREFIX_PATH</div><div class="line">else</div><div class="line">  export ROBOTPKG_BASE=$1</div><div class="line">  export PATH=$PATH:$ROBOTPKG_BASE/sbin:$ROBOTPKG_BASE/bin</div><div class="line">  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROBOTPKG_BASE/lib:$ROBOTPKG_BASE/lib/plugin:$ROBOTPKG_BASE/lib64</div><div class="line">  export PYTHONPATH=$PYTHONPATH:$ROBOTPKG_BASE/lib/python2.7/site-packages:$ROBOTPKG_BASE/lib/python2.7/dist-packages</div><div class="line">  export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$ROBOTPKG_BASE/lib/pkgconfig/</div><div class="line">  export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:$ROBOTPKG_BASE/share:$ROBOTPKG_BASE/stacks</div><div class="line">  export CMAKE_PREFIX_PATH=$CMAKE_PREFIX_PATH:$ROBOTPKG_BASE</div><div class="line">fi</div></div><!-- fragment --><h2>Whole body motion</h2>
<h3>Introduction</h3>
<p>The following is a quick introduction to a control structure which is implementing a hierarchical inverse kinematics.</p>
<h3>Start the simulation</h3>
<div class="fragment"><div class="line">roslaunch talos_gazebo talos_gazebo.launch</div></div><!-- fragment --><p>WARNING: The first time you are launching this command it might take some time because gazebo is downloading several models from Internet.</p>
<h3>Start the SoT-ROS interface for TALOS in simulation (Gazebo)</h3>
<div class="fragment"><div class="line">roslaunch roscontrol_sot_talos sot_talos_controller_gazebo.launch</div></div><!-- fragment --><p>### Start the motion of the robot </p><div class="fragment"><div class="line">cd /opt/openrobots/share/sot-talos/tests/</div><div class="line">python test.py</div></div><!-- fragment --><h3>Detailed explanation of test.py</h3>
<p>This script is run by a python interpreter outside the real-time control loop of the robot.</p>
<div class="fragment"><div class="line">#!/usr/bin/python</div><div class="line">import sys</div><div class="line">import rospy</div></div><!-- fragment --><p> The first lines are simply import system modules and the ros python interface.</p>
<div class="fragment"><div class="line">from std_srvs.srv import *</div></div><!-- fragment --><p> It is used to test if the services provided by the SoT-ROS interface are available.</p>
<div class="fragment"><div class="line">from dynamic_graph_bridge.srv import *</div><div class="line">from dynamic_graph_bridge_msgs.srv import *</div></div><!-- fragment --><p> Import the helper objects to access services provided by the SoT-ROS interface.</p>
<div class="fragment"><div class="line">def launchScript(code,title,description = &quot;&quot;):</div><div class="line">    raw_input(title+&#39;:   &#39;+description)</div><div class="line">    rospy.loginfo(title)</div><div class="line">    rospy.loginfo(code)</div><div class="line">    for line in code:</div><div class="line">        if line != &#39;&#39; and line[0] != &#39;#&#39;:</div><div class="line">            print line</div><div class="line">            answer = runCommandClient(str(line))</div><div class="line">            rospy.logdebug(answer)</div><div class="line">            print answer</div><div class="line">    rospy.loginfo(&quot;...done with &quot;+title)</div></div><!-- fragment --><p> This script is loading a python file which will be send to the embedded python interpreter of the SoT. It is waiting the user to hit the enter key after display the python file to be loaded.</p>
<div class="fragment"><div class="line"># Waiting for services</div><div class="line">try:</div><div class="line">    rospy.loginfo(&quot;Waiting for run_command&quot;)</div><div class="line">    rospy.wait_for_service(&#39;/run_command&#39;)</div><div class="line">    rospy.loginfo(&quot;...ok&quot;)</div><div class="line"></div><div class="line">    rospy.loginfo(&quot;Waiting for start_dynamic_graph&quot;)</div><div class="line">    rospy.wait_for_service(&#39;/start_dynamic_graph&#39;)</div><div class="line">    rospy.loginfo(&quot;...ok&quot;)</div></div><!-- fragment --><p> This part of the script waits that the services provided by SoT-ROS interface become available: </p><ul>
<li>
<b>run_command which</b> is the service to send python commands. </li>
<li>
<b>start_dynamic_graph</b> is the service to start the control of the robot. </li>
</ul>
<div class="fragment"><div class="line">runCommandClient = rospy.ServiceProxy(&#39;run_command&#39;, RunCommand)</div><div class="line">runCommandStartDynamicGraph = rospy.ServiceProxy(&#39;start_dynamic_graph&#39;, Empty)</div></div><!-- fragment --><p> Two helper objects are created to interact with the services.</p>
<div class="fragment"><div class="line">initCode = open( &quot;appli.py&quot;, &quot;r&quot;).read().split(&quot;\n&quot;)</div></div><!-- fragment --><p> The file <b>apply.py</b> explained below is loaded in the variable initCode. It basically the control graph that will be applied to the robot.</p>
<div class="fragment"><div class="line">rospy.loginfo(&quot;Stack of Tasks launched&quot;)</div><div class="line"></div><div class="line">launchScript(initCode,&#39;initialize SoT&#39;)</div></div><!-- fragment --><p> The last line is sending the script appli.py to the interpreter on the robot.</p>
<div class="fragment"><div class="line">raw_input(&quot;Wait before starting the dynamic graph&quot;)</div></div><!-- fragment --><p> This line prints the string and waits for the user to hit enter</p>
<div class="fragment"><div class="line">runCommandStartDynamicGraph()</div></div><!-- fragment --><p> The last line starts to apply the control law to the robot and evaluate the whole SoT control graph.</p>
<div class="fragment"><div class="line">raw_input(&quot;Wait before moving the hand&quot;)</div></div><!-- fragment --><p> This line prints the string and waits for the user to hit enter</p>
<div class="fragment"><div class="line">runCommandClient(&quot;target = (0.5,-0.2,1.0)&quot;)</div><div class="line">runCommandClient(&quot;gotoNd(taskRH,target,&#39;111&#39;,(4.9,0.9,0.01,0.9))&quot;)</div><div class="line">runCommandClient(&quot;sot.push(taskRH.task.name)&quot;)</div></div><!-- fragment --><p> The first <b>runCommandClient</b> specifies a target position in (X,Y,Z) coordinates. The second <b>runCommandClient</b> specifies the gains to apply to the task <b>taskRH</b> and the axis to control. Here '111' means that all axis are controlled. The last runCommandClient push the task <b>taskRH</b> in the solver.</p>
<div class="fragment"><div class="line">except rospy.ServiceException, e:</div><div class="line">    rospy.logerr(&quot;Service call failed: %s&quot; % e)</div></div><!-- fragment --><p> The last two lines deals with exception which might raise during the process.</p>
<h3>Detailed explanations of appli.py</h3>
<div class="fragment"><div class="line">from dynamic_graph.sot.core.meta_tasks_kine import MetaTaskKine6d, MetaTaskKineCom, gotoNd</div><div class="line">from dynamic_graph.sot.core.matrix_util import matrixToTuple</div><div class="line">from numpy import eye</div></div><!-- fragment --><p> The first line import object collecting objects to realize generic kinematic tasks.</p>
<div class="fragment"><div class="line">taskRH    = MetaTaskKine6d(&#39;rh&#39;,robot.dynamic,&#39;rh&#39;,robot.OperationalPointsMap[&#39;right-wrist&#39;])</div><div class="line">handMgrip = eye(4); handMgrip[0:3,3] = (0.1,0,0)</div><div class="line">taskRH.opmodif = matrixToTuple(handMgrip)</div><div class="line">taskRH.feature.frame(&#39;desired&#39;)</div></div><!-- fragment --><p> The first line create a task <b>rh</b> at the operational point 'right-wrist'. The second line creates a homogeneous matrix <b>handMgrip</b> . The rotational part is set to identity and the translation part is set to **(0.1,0.0,0.0)**. The third line set a modification of the operational point. It is such that the controlled frame is 'right-wrist' multiplied at the left by <b>handMgrip</b>.</p>
<div class="fragment"><div class="line"># --- STATIC COM (if not walking)</div><div class="line">taskCom = MetaTaskKineCom(robot.dynamic)</div><div class="line">robot.dynamic.com.recompute(0)</div><div class="line">taskCom.featureDes.errorIN.value = robot.dynamic.com.value</div><div class="line">taskCom.task.controlGain.value = 10</div></div><!-- fragment --><p> This task controls the CoM of the robot by reading the output of the entity <b>robot.dynamic</b>. The second line initialize the output value of signal <b>robot.dynamic.com</b>. It becomes the desired value in the third line. The control gain is set to 10 in the fourth line.</p>
<div class="fragment"><div class="line"># --- CONTACTS</div><div class="line">#define contactLF and contactRF</div><div class="line">contactLF = MetaTaskKine6d(&#39;contactLF&#39;,robot.dynamic,&#39;LF&#39;,robot.OperationalPointsMap[&#39;left-ankle&#39;])</div><div class="line">contactLF.feature.frame(&#39;desired&#39;)</div><div class="line">contactLF.gain.setConstant(10)</div><div class="line">contactLF.keep()</div><div class="line">locals()[&#39;contactLF&#39;] = contactLF</div></div><!-- fragment --><p> The first line create a set of object necessary to maintain contact with the left-ankle. The second line specifies the name of the desired feature. The third line specifies the gain of the contact. The fourth line maintains the position as a constraint.</p>
<div class="fragment"><div class="line">contactRF = MetaTaskKine6d(&#39;contactRF&#39;,robot.dynamic,&#39;RF&#39;,robot.OperationalPointsMap[&#39;right-ankle&#39;])</div><div class="line">contactRF.feature.frame(&#39;desired&#39;)</div><div class="line">contactRF.gain.setConstant(10)</div><div class="line">contactRF.keep()</div><div class="line">locals()[&#39;contactRF&#39;] = contactRF</div></div><!-- fragment --><p> The lines specified here are the same than for the previous contact.</p>
<div class="fragment"><div class="line">from dynamic_graph import plug</div><div class="line">from dynamic_graph.sot.core import SOT</div></div><!-- fragment --><p> The first line import bindings to the lower C++ framework. </p><div class="fragment"><div class="line">sot = SOT(&#39;sot&#39;)</div><div class="line">sot.setSize(robot.dynamic.getDimension())</div><div class="line">plug(sot.control,robot.device.control)</div></div><!-- fragment --><p> The first line instantiates a solver to generate a kinematic solver. The second line defines the size of free variables. The third line links the solution of the solver to the input of the robot.</p>
<div class="fragment"><div class="line">from dynamic_graph.ros import RosPublish</div><div class="line">ros_publish_state = RosPublish (&quot;ros_publish_state&quot;)</div><div class="line">ros_publish_state.add (&quot;vector&quot;, &quot;state&quot;, &quot;/sot_control/state&quot;)</div></div><!-- fragment --><p> The first line import the python module to publish data in the ROS world (aka topics). The second line instantiate the object to make the interface from the Stack-Of-Tasks world to the ROS world. It creates an entity called "ros_publish_state".</p>
<p>The third line adds a topic called **/sot_control/state** from the signal <b>state</b> of the entity <b>ros_publish_state</b></p>
<div class="fragment"><div class="line">plug (robot.device.state, ros_publish_state.state)</div><div class="line">robot.device.after.addDownsampledSignal (&quot;ros_publish_state.trigger&quot;, 100)</div></div><!-- fragment --><p> The first line connect the signal <b>robot.device.state</b> to the the signal <b>state</b> of the entity <b>ros_publish_state</b>. The second line calls the signal <b>ros_publish_state.trigger</b> at 100 Hz after evaluating the control law.</p>
<div class="fragment"><div class="line">sot.push(contactRF.task.name)</div><div class="line">sot.push(contactLF.task.name)</div><div class="line">sot.push(taskCom.task.name)</div><div class="line">robot.device.control.recompute(0)</div></div><!-- fragment --><p> The first line push the right foot contact task at the top of the SoT. The second line push the left foot contact task in the SoT. The third line push the CoM task in the SoT. The last line ask for a re-computation of the signal named <b>control</b> which belongs to the entity <b>device</b>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 17 2020 07:26:17 for sot-doc by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
